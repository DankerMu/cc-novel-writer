#!/usr/bin/env bash
#
# Compare two archived regression runs (M3).
#
# Usage:
#   compare-regression-runs.sh <run_dir_a> <run_dir_b> [--out <delta.json>]
#
# Output:
#   stdout JSON (exit 0 on success)
#
# Exit codes:
#   0 = success (valid JSON emitted to stdout)
#   1 = validation failure (bad args, missing files, invalid JSON)
#   2 = script exception (unexpected runtime error)

set -euo pipefail

usage() {
  cat >&2 <<'EOF'
Usage:
  compare-regression-runs.sh <run_dir_a> <run_dir_b> [--out <delta.json>]

Notes:
  - Expects each run dir to contain summary.json (generated by scripts/run-regression.sh).
EOF
}

out_path=""

if [ "$#" -lt 2 ]; then
  usage
  exit 1
fi

run_a="$1"
run_b="$2"
shift 2

while [ "$#" -gt 0 ]; do
  case "$1" in
    --out)
      [ "$#" -ge 2 ] || { echo "compare-regression-runs.sh: error: --out requires a value" >&2; exit 1; }
      out_path="$2"
      shift 2
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "compare-regression-runs.sh: unknown arg: $1" >&2
      usage
      exit 1
      ;;
  esac
done

if [ ! -d "$run_a" ]; then
  echo "compare-regression-runs.sh: run_dir_a not found: $run_a" >&2
  exit 1
fi
if [ ! -d "$run_b" ]; then
  echo "compare-regression-runs.sh: run_dir_b not found: $run_b" >&2
  exit 1
fi

summary_a="$run_a/summary.json"
summary_b="$run_b/summary.json"

if [ ! -f "$summary_a" ]; then
  echo "compare-regression-runs.sh: missing summary.json: $summary_a" >&2
  exit 1
fi
if [ ! -f "$summary_b" ]; then
  echo "compare-regression-runs.sh: missing summary.json: $summary_b" >&2
  exit 1
fi

if ! command -v python3 >/dev/null 2>&1; then
  echo "compare-regression-runs.sh: python3 is required but not found" >&2
  exit 1
fi

python3 - "$summary_a" "$summary_b" "$out_path" <<'PY'
import json
import math
import os
import sys
from datetime import datetime, timezone
from typing import Any, Dict, Optional


def _die(msg: str, exit_code: int = 1) -> None:
    sys.stderr.write(msg.rstrip() + "\n")
    raise SystemExit(exit_code)


def _load_json(path: str) -> Any:
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception as e:
        _die(f"compare-regression-runs.sh: invalid JSON at {path}: {e}", 1)


def _iso_utc_now() -> str:
    return datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")


def _as_number(v: Any) -> Optional[float]:
    if isinstance(v, (int, float)) and not isinstance(v, bool):
        val = float(v)
        return val if math.isfinite(val) else None
    return None


def _delta_number(a: Any, b: Any) -> Optional[float]:
    na = _as_number(a)
    nb = _as_number(b)
    if na is None or nb is None:
        return None
    return nb - na


def _delta_dim_means(a: Any, b: Any) -> Dict[str, Optional[float]]:
    """Delta on score_dimensions: extract 'mean' from {n, mean} objects."""
    if not isinstance(a, dict):
        a = {}
    if not isinstance(b, dict):
        b = {}
    keys = sorted(set(list(a.keys()) + list(b.keys())))
    out: Dict[str, Optional[float]] = {}
    for k in keys:
        va = a.get(k)
        vb = b.get(k)
        ma = _as_number(va.get("mean")) if isinstance(va, dict) else None
        mb = _as_number(vb.get("mean")) if isinstance(vb, dict) else None
        if ma is None and mb is None:
            continue
        if ma is None or mb is None:
            out[k] = None
        else:
            out[k] = round(float(mb - ma), 6)
    return out


def _delta_map(a: Any, b: Any) -> Dict[str, Optional[float]]:
    if not isinstance(a, dict):
        a = {}
    if not isinstance(b, dict):
        b = {}
    keys = set([str(k) for k in a.keys()] + [str(k) for k in b.keys()])
    out: Dict[str, Optional[float]] = {}
    for k in sorted(keys):
        da = _as_number(a.get(k))
        db = _as_number(b.get(k))
        if da is None and db is None:
            continue
        if da is None or db is None:
            out[k] = None
        else:
            out[k] = float(db - da)
    return out


def main() -> None:
    path_a = sys.argv[1]
    path_b = sys.argv[2]
    out_path = sys.argv[3].strip() if len(sys.argv) > 3 else ""

    a = _load_json(path_a)
    b = _load_json(path_b)
    if not isinstance(a, dict) or not isinstance(b, dict):
        _die("compare-regression-runs.sh: both summaries must be JSON objects", 1)

    comp_a = a.get("compliance") if isinstance(a.get("compliance"), dict) else {}
    comp_b = b.get("compliance") if isinstance(b.get("compliance"), dict) else {}

    score_a = a.get("score_overall") if isinstance(a.get("score_overall"), dict) else {}
    score_b = b.get("score_overall") if isinstance(b.get("score_overall"), dict) else {}

    out = {
        "schema_version": 1,
        "generated_at": _iso_utc_now(),
        "run_a": {"dir": os.path.dirname(os.path.abspath(path_a)), "summary_path": os.path.abspath(path_a), "run_id": a.get("run_id")},
        "run_b": {"dir": os.path.dirname(os.path.abspath(path_b)), "summary_path": os.path.abspath(path_b), "run_id": b.get("run_id")},
        "delta": {
            "chapters_total": _delta_number(a.get("chapters_total"), b.get("chapters_total")),
            "violations_total": _delta_number(a.get("violations_total"), b.get("violations_total")),
            "compliance_rate_high_confidence": _delta_number(comp_a.get("compliance_rate_high_confidence"), comp_b.get("compliance_rate_high_confidence")),
            "compliance_rate_any_violation": _delta_number(comp_a.get("compliance_rate_any_violation"), comp_b.get("compliance_rate_any_violation")),
            "chapters_with_high_confidence_violation": _delta_number(
                comp_a.get("chapters_with_high_confidence_violation"), comp_b.get("chapters_with_high_confidence_violation")
            ),
            "chapters_with_any_violation": _delta_number(comp_a.get("chapters_with_any_violation"), comp_b.get("chapters_with_any_violation")),
            "violations_by_confidence": _delta_map(a.get("violations_by_confidence"), b.get("violations_by_confidence")),
            "violations_by_layer": _delta_map(a.get("violations_by_layer"), b.get("violations_by_layer")),
            "score_overall_mean": _delta_number(score_a.get("mean"), score_b.get("mean")),
        },
        "score_dimensions": {},
        "notes": [],
    }

    if _as_number(a.get("chapters_total")) != _as_number(b.get("chapters_total")):
        out["notes"].append("chapters_total differs; compare deltas with caution.")

    dims_a = a.get("score_dimensions", {})
    dims_b = b.get("score_dimensions", {})
    if dims_a or dims_b:
        out["score_dimensions"] = _delta_dim_means(dims_a, dims_b)

    out_json = json.dumps(out, ensure_ascii=False, sort_keys=True) + "\n"
    sys.stdout.write(out_json)

    if out_path:
        out_dir = os.path.dirname(os.path.abspath(out_path))
        if out_dir and not os.path.isdir(out_dir):
            os.makedirs(out_dir, exist_ok=True)
        try:
            with open(out_path, "w", encoding="utf-8") as f:
                f.write(out_json)
        except Exception as e:
            _die(f"compare-regression-runs.sh: failed to write to {out_path}: {e}", 1)


try:
    main()
except SystemExit:
    raise
except Exception as e:
    sys.stderr.write(f"compare-regression-runs.sh: unexpected error: {e}\n")
    raise SystemExit(2)
PY

